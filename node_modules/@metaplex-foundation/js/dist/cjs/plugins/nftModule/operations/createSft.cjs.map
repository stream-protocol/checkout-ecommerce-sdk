{"version":3,"file":"createSft.cjs","sources":["../../../../../src/plugins/nftModule/operations/createSft.ts"],"sourcesContent":["import {\n  createCreateMetadataAccountV3Instruction,\n  Uses,\n} from '@metaplex-foundation/mpl-token-metadata';\nimport { Keypair, PublicKey } from '@solana/web3.js';\nimport { SendAndConfirmTransactionResponse } from '../../rpcModule';\nimport { assertSft, Sft, SftWithToken } from '../models';\nimport { Option, TransactionBuilder, TransactionBuilderOptions } from '@/utils';\nimport {\n  Creator,\n  CreatorInput,\n  isSigner,\n  makeConfirmOptionsFinalizedOnMainnet,\n  Operation,\n  OperationHandler,\n  OperationScope,\n  Signer,\n  SplTokenAmount,\n  toPublicKey,\n  useOperation,\n} from '@/types';\nimport { Metaplex } from '@/Metaplex';\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'CreateSftOperation' as const;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const { sft } = await metaplex\n *   .nfts()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   };\n * ```\n *\n * @group Operations\n * @category Constructors\n */\nexport const createSftOperation = useOperation<CreateSftOperation>(Key);\n\n/**\n * @group Operations\n * @category Types\n */\nexport type CreateSftOperation = Operation<\n  typeof Key,\n  CreateSftInput,\n  CreateSftOutput\n>;\n\n/**\n * @group Operations\n * @category Inputs\n */\nexport type CreateSftInput = {\n  /**\n   * The authority that will be able to make changes\n   * to the created SFT.\n   *\n   * This is required as a Signer because creating the\n   * metadata account requires the update authority to be part\n   * of the creators array as a verified creator.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  updateAuthority?: Signer;\n\n  /**\n   * The authority allowed to mint new tokens for the mint account\n   * that is either explicitly provided or about to be created.\n   *\n   * @defaultValue `metaplex.identity()`\n   */\n  mintAuthority?: Signer;\n\n  /**\n   * The authority allowed to freeze token account associated with the\n   * mint account that is either explicitly provided or about to be created.\n   *\n   * @defaultValue `metaplex.identity().publicKey`\n   */\n  freezeAuthority?: Option<PublicKey>;\n\n  /**\n   * The address of the new mint account as a Signer.\n   * This is useful if you already have a generated Keypair\n   * for the mint account of the SFT to create.\n   *\n   * @defaultValue `Keypair.generate()`\n   */\n  useNewMint?: Signer;\n\n  /**\n   * The address of the existing mint account that should be converted\n   * into an SFT. The account at this address should have the right\n   * requirements to become an SFT, e.g. it shouldn't already have\n   * a metadata account associated with it.\n   *\n   * @defaultValue Defaults to creating a new mint account with the\n   * right requirements.\n   */\n  useExistingMint?: PublicKey;\n\n  /**\n   * The owner of a token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account. When provided, an associated\n   * token account will be created from the given owner.\n   *\n   * You may alternatively pass the `tokenAddress` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenOwner?: PublicKey;\n\n  /**\n   * An explicit token account associated with the SFT to create.\n   *\n   * This is completely optional as creating an SFT does not require\n   * the existence of a token account.\n   *\n   * When provided, the token account will be created if and only\n   * if no account exists at the given address. When that's the case,\n   * the `tokenAddress` must be provided as a Signer as we're creating\n   * and initializing the account at this address.\n   *\n   * You may alternatively pass the `tokenOwner` parameter instead.\n   *\n   * @defaultValue Defaults to not creating and/or minting\n   * any token account.\n   */\n  tokenAddress?: PublicKey | Signer;\n\n  /**\n   * The amount of tokens to mint to the token account initially\n   * if a token account is created.\n   *\n   * This is only relevant if either the `tokenOwner` or `tokenAddress`\n   * is provided.\n   *\n   * @defaultValue Defaults to not minting any tokens.\n   */\n  tokenAmount?: SplTokenAmount;\n\n  /**\n   * The number of decimal points used to define token amounts.\n   *\n   * @defaultValue `0`\n   */\n  decimals?: number;\n\n  /** The URI that points to the JSON metadata of the asset. */\n  uri: string;\n\n  /** The on-chain name of the asset, e.g. \"My SFT\". */\n  name: string;\n\n  /**\n   * The royalties in percent basis point (i.e. 250 is 2.5%) that\n   * should be paid to the creators on each secondary sale.\n   */\n  sellerFeeBasisPoints: number;\n\n  /**\n   * The on-chain symbol of the asset, stored in the Metadata account.\n   * E.g. \"MYSFT\".\n   *\n   * @defaultValue `\"\"`\n   */\n  symbol?: string;\n\n  /**\n   * {@inheritDoc CreatorInput}\n   * @defaultValue\n   * Defaults to using the provided `updateAuthority` as the only verified creator.\n   * ```ts\n   * [{\n   *   address: updateAuthority.publicKey,\n   *   authority: updateAuthority,\n   *   share: 100,\n   * }]\n   * ```\n   */\n  creators?: CreatorInput[];\n\n  /**\n   * Whether or not the SFT's metadata is mutable.\n   * When set to `false` no one can update the Metadata account,\n   * not even the update authority.\n   *\n   * @defaultValue `true`\n   */\n  isMutable?: boolean;\n\n  /**\n   * When this field is not `null`, it indicates that the SFT\n   * can be \"used\" by its owner or any approved \"use authorities\".\n   *\n   * @defaultValue `null`\n   */\n  uses?: Option<Uses>;\n\n  /**\n   * Whether the created SFT is a Collection SFT.\n   * When set to `true`, the SFT will be created as a\n   * Sized Collection SFT with an initial size of 0.\n   *\n   * @defaultValue `false`\n   */\n  isCollection?: boolean;\n\n  /**\n   * The Collection NFT that this new SFT belongs to.\n   * When `null`, the created SFT will not be part of a collection.\n   *\n   * @defaultValue `null`\n   */\n  collection?: Option<PublicKey>;\n\n  /**\n   * The collection authority that should sign the created SFT\n   * to prove that it is part of the provided collection.\n   * When `null`, the provided `collection` will not be verified.\n   *\n   * @defaultValue `null`\n   */\n  collectionAuthority?: Option<Signer>;\n\n  /**\n   * Whether or not the provided `collectionAuthority` is a delegated\n   * collection authority, i.e. it was approved by the update authority\n   * using `metaplex.nfts().approveCollectionAuthority()`.\n   *\n   * @defaultValue `false`\n   */\n  collectionAuthorityIsDelegated?: boolean;\n\n  /**\n   * Whether or not the provided `collection` is a sized collection\n   * and not a legacy collection.\n   *\n   * @defaultValue `true`\n   */\n  collectionIsSized?: boolean;\n};\n\n/**\n * @group Operations\n * @category Outputs\n */\nexport type CreateSftOutput = {\n  /** The blockchain response from sending and confirming the transaction. */\n  response: SendAndConfirmTransactionResponse;\n\n  /** The newly created SFT and, potentially, its associated token. */\n  sft: Sft | SftWithToken;\n\n  /** The address of the mint account. */\n  mintAddress: PublicKey;\n\n  /** The address of the metadata account. */\n  metadataAddress: PublicKey;\n\n  /** The address of the token account if any. */\n  tokenAddress: PublicKey | null;\n};\n\n/**\n * @group Operations\n * @category Handlers\n */\nexport const createSftOperationHandler: OperationHandler<CreateSftOperation> = {\n  handle: async (\n    operation: CreateSftOperation,\n    metaplex: Metaplex,\n    scope: OperationScope\n  ) => {\n    const {\n      useNewMint = Keypair.generate(),\n      useExistingMint,\n      tokenOwner,\n      tokenAddress: tokenSigner,\n    } = operation.input;\n\n    const mintAddress = useExistingMint ?? useNewMint.publicKey;\n    const associatedTokenAddress = tokenOwner\n      ? metaplex.tokens().pdas().associatedTokenAccount({\n          mint: mintAddress,\n          owner: tokenOwner,\n          programs: scope.programs,\n        })\n      : null;\n    const tokenAddress = tokenSigner\n      ? toPublicKey(tokenSigner)\n      : associatedTokenAddress;\n\n    let tokenExists: boolean;\n    if (!!useExistingMint && !!tokenAddress) {\n      const tokenAccount = await metaplex.rpc().getAccount(tokenAddress);\n      tokenExists = tokenAccount.exists;\n    } else {\n      tokenExists = false;\n    }\n\n    const builder = await createSftBuilder(\n      metaplex,\n      { ...operation.input, useNewMint, tokenExists },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    const confirmOptions = makeConfirmOptionsFinalizedOnMainnet(\n      metaplex,\n      scope.confirmOptions\n    );\n    const output = await builder.sendAndConfirm(metaplex, confirmOptions);\n    scope.throwIfCanceled();\n\n    const sft = await metaplex.nfts().findByMint(\n      {\n        mintAddress: output.mintAddress,\n        tokenAddress: output.tokenAddress ?? undefined,\n      },\n      scope\n    );\n    scope.throwIfCanceled();\n\n    assertSft(sft);\n    return { ...output, sft };\n  },\n};\n\n// -----------------\n// Builder\n// -----------------\n\n/**\n * @group Transaction Builders\n * @category Inputs\n */\nexport type CreateSftBuilderParams = Omit<CreateSftInput, 'confirmOptions'> & {\n  /**\n   * Whether or not the provided token account already exists.\n   * If `false`, we'll add another instruction to create it.\n   *\n   * @defaultValue `true`\n   */\n  tokenExists?: boolean;\n\n  /** A key to distinguish the instruction that creates the mint account. */\n  createMintAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the mint account. */\n  initializeMintInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the associated token account. */\n  createAssociatedTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the token account. */\n  createTokenAccountInstructionKey?: string;\n\n  /** A key to distinguish the instruction that initializes the token account. */\n  initializeTokenInstructionKey?: string;\n\n  /** A key to distinguish the instruction that mints tokens. */\n  mintTokensInstructionKey?: string;\n\n  /** A key to distinguish the instruction that creates the metadata account. */\n  createMetadataInstructionKey?: string;\n};\n\n/**\n * @group Transaction Builders\n * @category Contexts\n */\nexport type CreateSftBuilderContext = Omit<CreateSftOutput, 'response' | 'sft'>;\n\n/**\n * Creates a new SFT.\n *\n * ```ts\n * const transactionBuilder = await metaplex\n *   .nfts()\n *   .builders()\n *   .createSft({\n *     name: 'My SFT',\n *     uri: 'https://example.com/my-sft',\n *     sellerFeeBasisPoints: 250, // 2.5%\n *   });\n * ```\n *\n * @group Transaction Builders\n * @category Constructors\n */\nexport const createSftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateSftBuilderParams,\n  options: TransactionBuilderOptions = {}\n): Promise<TransactionBuilder<CreateSftBuilderContext>> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    useNewMint = Keypair.generate(),\n    updateAuthority = metaplex.identity(),\n    mintAuthority = metaplex.identity(),\n  } = params;\n\n  const mintAndTokenBuilder = await createMintAndTokenForSftBuilder(\n    metaplex,\n    params,\n    { programs, payer },\n    useNewMint\n  );\n  const { mintAddress, tokenAddress } = mintAndTokenBuilder.getContext();\n\n  const tokenMetadataProgram = metaplex.programs().getTokenMetadata(programs);\n  const metadataPda = metaplex.nfts().pdas().metadata({\n    mint: mintAddress,\n    programs,\n  });\n  const creatorsInput: CreatorInput[] = params.creators ?? [\n    {\n      address: updateAuthority.publicKey,\n      authority: updateAuthority,\n      share: 100,\n    },\n  ];\n  const creators: Option<Creator[]> =\n    creatorsInput.length > 0\n      ? creatorsInput.map((creator) => ({\n          ...creator,\n          verified: creator.address.equals(updateAuthority.publicKey),\n        }))\n      : null;\n\n  const createMetadataInstruction = createCreateMetadataAccountV3Instruction(\n    {\n      metadata: metadataPda,\n      mint: mintAddress,\n      mintAuthority: mintAuthority.publicKey,\n      payer: payer.publicKey,\n      updateAuthority: updateAuthority.publicKey,\n    },\n    {\n      createMetadataAccountArgsV3: {\n        data: {\n          name: params.name,\n          symbol: params.symbol ?? '',\n          uri: params.uri,\n          sellerFeeBasisPoints: params.sellerFeeBasisPoints,\n          creators,\n          collection: params.collection\n            ? { key: params.collection, verified: false }\n            : null,\n          uses: params.uses ?? null,\n        },\n        isMutable: params.isMutable ?? true,\n        collectionDetails: params.isCollection\n          ? { __kind: 'V1', size: 0 } // Program will hardcode size to zero anyway.\n          : null,\n      },\n    },\n    tokenMetadataProgram.address\n  );\n\n  // When the payer is different than the update authority, the latter will\n  // not be marked as a signer and therefore signing as a creator will fail.\n  createMetadataInstruction.keys[4].isSigner = true;\n\n  const verifyAdditionalCreatorInstructions = creatorsInput\n    .filter((creator) => {\n      return (\n        !!creator.authority &&\n        !creator.address.equals(updateAuthority.publicKey)\n      );\n    })\n    .map((creator) => {\n      return metaplex.nfts().builders().verifyCreator(\n        {\n          mintAddress,\n          creator: creator.authority,\n        },\n        { programs, payer }\n      );\n    });\n\n  return (\n    TransactionBuilder.make<CreateSftBuilderContext>()\n      .setFeePayer(payer)\n      .setContext({\n        mintAddress,\n        metadataAddress: metadataPda,\n        tokenAddress,\n      })\n\n      // Create the mint and token accounts before minting 1 token to the owner.\n      .add(mintAndTokenBuilder)\n\n      // Create metadata account.\n      .add({\n        instruction: createMetadataInstruction,\n        signers: [payer, mintAuthority, updateAuthority],\n        key: params.createMetadataInstructionKey ?? 'createMetadata',\n      })\n\n      // Verify additional creators.\n      .add(...verifyAdditionalCreatorInstructions)\n\n      // Verify collection.\n      .when(!!params.collection && !!params.collectionAuthority, (builder) =>\n        builder.add(\n          metaplex\n            .nfts()\n            .builders()\n            .verifyCollection(\n              {\n                mintAddress,\n                collectionMintAddress: params.collection as PublicKey,\n                collectionAuthority: params.collectionAuthority as Signer,\n                isDelegated: params.collectionAuthorityIsDelegated ?? false,\n                isSizedCollection: params.collectionIsSized ?? true,\n              },\n              { payer, programs }\n            )\n        )\n      )\n  );\n};\n\nconst createMintAndTokenForSftBuilder = async (\n  metaplex: Metaplex,\n  params: CreateSftBuilderParams,\n  options: TransactionBuilderOptions,\n  useNewMint: Signer\n): Promise<\n  TransactionBuilder<{ mintAddress: PublicKey; tokenAddress: PublicKey | null }>\n> => {\n  const { programs, payer = metaplex.rpc().getDefaultFeePayer() } = options;\n  const {\n    mintAuthority = metaplex.identity(),\n    freezeAuthority = metaplex.identity().publicKey,\n    tokenExists = false,\n  } = params;\n\n  const mintAddress = params.useExistingMint ?? useNewMint.publicKey;\n  const associatedTokenAddress = params.tokenOwner\n    ? metaplex.tokens().pdas().associatedTokenAccount({\n        mint: mintAddress,\n        owner: params.tokenOwner,\n        programs,\n      })\n    : null;\n  const tokenAddress = params.tokenAddress\n    ? toPublicKey(params.tokenAddress)\n    : associatedTokenAddress;\n\n  const builder = TransactionBuilder.make<{\n    mintAddress: PublicKey;\n    tokenAddress: PublicKey | null;\n  }>()\n    .setFeePayer(payer)\n    .setContext({\n      mintAddress,\n      tokenAddress,\n    });\n\n  // Create the mint account if it doesn't exist.\n  if (!params.useExistingMint) {\n    builder.add(\n      await metaplex\n        .tokens()\n        .builders()\n        .createMint(\n          {\n            decimals: params.decimals ?? 0,\n            mint: useNewMint,\n            mintAuthority: mintAuthority.publicKey,\n            freezeAuthority,\n            createAccountInstructionKey: params.createMintAccountInstructionKey,\n            initializeMintInstructionKey: params.initializeMintInstructionKey,\n          },\n          { programs, payer }\n        )\n    );\n  }\n\n  // Create the token account if it doesn't exist.\n  const isNewToken = !!params.tokenAddress && isSigner(params.tokenAddress);\n  const isNewAssociatedToken = !!params.tokenOwner;\n  if (!tokenExists && (isNewToken || isNewAssociatedToken)) {\n    builder.add(\n      await metaplex\n        .tokens()\n        .builders()\n        .createToken(\n          {\n            mint: mintAddress,\n            owner: params.tokenOwner,\n            token: params.tokenAddress as Signer | undefined,\n            createAssociatedTokenAccountInstructionKey:\n              params.createAssociatedTokenAccountInstructionKey,\n            createAccountInstructionKey:\n              params.createTokenAccountInstructionKey,\n            initializeTokenInstructionKey: params.initializeTokenInstructionKey,\n          },\n          { programs, payer }\n        )\n    );\n  }\n\n  // Mint provided amount to the token account.\n  if (tokenAddress && params.tokenAmount) {\n    builder.add(\n      await metaplex.tokens().builders().mint(\n        {\n          mintAddress,\n          toToken: tokenAddress,\n          toTokenExists: true,\n          amount: params.tokenAmount,\n          mintAuthority,\n          mintTokensInstructionKey: params.mintTokensInstructionKey,\n        },\n        { programs, payer }\n      )\n    );\n  }\n\n  return builder;\n};\n"],"names":["Key","createSftOperation","useOperation","createSftOperationHandler","handle","operation","metaplex","scope","useNewMint","Keypair","generate","useExistingMint","tokenOwner","tokenAddress","tokenSigner","input","mintAddress","publicKey","associatedTokenAddress","tokens","pdas","associatedTokenAccount","mint","owner","programs","toPublicKey","tokenExists","tokenAccount","rpc","getAccount","exists","builder","createSftBuilder","throwIfCanceled","confirmOptions","makeConfirmOptionsFinalizedOnMainnet","output","sendAndConfirm","sft","nfts","findByMint","undefined","assertSft","params","options","payer","getDefaultFeePayer","updateAuthority","identity","mintAuthority","mintAndTokenBuilder","createMintAndTokenForSftBuilder","getContext","tokenMetadataProgram","getTokenMetadata","metadataPda","metadata","creatorsInput","creators","address","authority","share","length","map","creator","verified","equals","createMetadataInstruction","createCreateMetadataAccountV3Instruction","createMetadataAccountArgsV3","data","name","symbol","uri","sellerFeeBasisPoints","collection","key","uses","isMutable","collectionDetails","isCollection","__kind","size","keys","isSigner","verifyAdditionalCreatorInstructions","filter","builders","verifyCreator","TransactionBuilder","make","setFeePayer","setContext","metadataAddress","add","instruction","signers","createMetadataInstructionKey","when","collectionAuthority","verifyCollection","collectionMintAddress","isDelegated","collectionAuthorityIsDelegated","isSizedCollection","collectionIsSized","freezeAuthority","createMint","decimals","createAccountInstructionKey","createMintAccountInstructionKey","initializeMintInstructionKey","isNewToken","isNewAssociatedToken","createToken","token","createAssociatedTokenAccountInstructionKey","createTokenAccountInstructionKey","initializeTokenInstructionKey","tokenAmount","toToken","toTokenExists","amount","mintTokensInstructionKey"],"mappings":"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"}